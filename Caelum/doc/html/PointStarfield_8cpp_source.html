<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Caelum: main/src/PointStarfield.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>main/src/PointStarfield.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">This file is part of Caelum.</span>
<a name="l00003"></a>00003 <span class="comment">See http://www.ogre3d.org/wiki/index.php/Caelum </span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">Copyright (c) 2008 Caelum team. See Contributors.txt for details.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">Caelum is free software: you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">it under the terms of the GNU Lesser General Public License as published</span>
<a name="l00009"></a>00009 <span class="comment">by the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">(at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">Caelum is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">GNU Lesser General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">You should have received a copy of the GNU Lesser General Public License</span>
<a name="l00018"></a>00018 <span class="comment">along with Caelum. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment">*/</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include "CaelumPrecompiled.h"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include "PointStarfield.h"</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include "CaelumExceptions.h"</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include "Astronomy.h"</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include "InternalUtilities.h"</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="keyword">using namespace </span>Ogre;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="keyword">namespace </span>Caelum
<a name="l00030"></a>00030 {
<a name="l00031"></a>00031     <span class="keyword">const</span> Ogre::String <a class="code" href="classCaelum_1_1PointStarfield.html#9d850ca76d8f7aa564e9b98ab8bc88d2" title="Material used to draw all the points.">PointStarfield::STARFIELD_MATERIAL_NAME</a> = <span class="stringliteral">"Caelum/StarPoint"</span>;
<a name="l00032"></a>00032     <span class="keyword">const</span> Ogre::Degree PointStarfield::DEFAULT_OBSERVER_POSITION_REBUILD_DELTA = Ogre::Degree(0.1);
<a name="l00033"></a>00033 
<a name="l00034"></a><a class="code" href="classCaelum_1_1PointStarfield.html#f51ac2567ea9e3d11f2631f2173972ec">00034</a>     <a class="code" href="classCaelum_1_1PointStarfield.html#f51ac2567ea9e3d11f2631f2173972ec" title="Constructor.">PointStarfield::PointStarfield</a> (
<a name="l00035"></a>00035             Ogre::SceneManager *sceneMgr,
<a name="l00036"></a>00036             Ogre::SceneNode *caelumRootNode,
<a name="l00037"></a>00037             <span class="keywordtype">bool</span> initWithCatalogue)
<a name="l00038"></a>00038     {
<a name="l00039"></a>00039         mMag0PixelSize = 16;
<a name="l00040"></a>00040         mMinPixelSize = 4;
<a name="l00041"></a>00041         mMaxPixelSize = 6;
<a name="l00042"></a>00042         mMagnitudeScale = Math::Pow(100, 0.2);
<a name="l00043"></a>00043         mObserverLatitude = 45;
<a name="l00044"></a>00044         mObserverLongitude = 0;
<a name="l00045"></a>00045         mObserverPositionRebuildDelta = DEFAULT_OBSERVER_POSITION_REBUILD_DELTA;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047         String uniqueSuffix = <span class="stringliteral">"/"</span> + <a class="code" href="classCaelum_1_1InternalUtilities.html#da1832b5022d1ad78847150f2cf2e4d5" title="Quickly format a pointer as a string; in hex.">InternalUtilities::pointerToString</a>(<span class="keyword">this</span>);
<a name="l00048"></a>00048 
<a name="l00049"></a>00049         <span class="comment">// Load material.</span>
<a name="l00050"></a>00050         mMaterial.<a class="code" href="classCaelum_1_1PrivatePtr.html#aa15793f77deb2577a1ebfa93750d093" title="Change the inner value.">reset</a>(<a class="code" href="classCaelum_1_1InternalUtilities.html#086f7ac3e4dd261e34e3af835455d4c7" title="Creates a private clone of a material from a script.">InternalUtilities::checkLoadMaterialClone</a>(
<a name="l00051"></a>00051                     <a class="code" href="classCaelum_1_1PointStarfield.html#9d850ca76d8f7aa564e9b98ab8bc88d2" title="Material used to draw all the points.">STARFIELD_MATERIAL_NAME</a>,
<a name="l00052"></a>00052                     <a class="code" href="classCaelum_1_1PointStarfield.html#9d850ca76d8f7aa564e9b98ab8bc88d2" title="Material used to draw all the points.">STARFIELD_MATERIAL_NAME</a> + uniqueSuffix));
<a name="l00053"></a>00053 
<a name="l00054"></a>00054         mParams.setup(mMaterial-&gt;getTechnique(0)-&gt;getPass(0)-&gt;getVertexProgramParameters());
<a name="l00055"></a>00055 
<a name="l00056"></a>00056         <span class="comment">// We use a separate data source.</span>
<a name="l00057"></a>00057         Ogre::String objName = <span class="stringliteral">"Caelum/PointStarfield"</span> + uniqueSuffix;
<a name="l00058"></a>00058         mManualObj.<a class="code" href="classCaelum_1_1PrivatePtr.html#aa15793f77deb2577a1ebfa93750d093" title="Change the inner value.">reset</a> (sceneMgr-&gt;createManualObject (objName));
<a name="l00059"></a>00059         mManualObj-&gt;setDynamic(<span class="keyword">false</span>);
<a name="l00060"></a>00060         mManualObj-&gt;setRenderQueueGroup (CAELUM_RENDER_QUEUE_STARFIELD);
<a name="l00061"></a>00061         sceneMgr-&gt;getRenderQueue()-&gt;getQueueGroup(CAELUM_RENDER_QUEUE_STARFIELD)-&gt;setShadowsEnabled (<span class="keyword">false</span>);
<a name="l00062"></a>00062         mManualObj-&gt;setCastShadows(<span class="keyword">false</span>);
<a name="l00063"></a>00063 
<a name="l00064"></a>00064         mNode.<a class="code" href="classCaelum_1_1PrivatePtr.html#aa15793f77deb2577a1ebfa93750d093" title="Change the inner value.">reset</a> (caelumRootNode-&gt;createChildSceneNode ());
<a name="l00065"></a>00065         mNode-&gt;attachObject (mManualObj.getPointer ());
<a name="l00066"></a>00066 
<a name="l00067"></a>00067         <span class="keywordflow">if</span> (initWithCatalogue) {
<a name="l00068"></a>00068             <a class="code" href="classCaelum_1_1PointStarfield.html#5a82c953f3c6bff038100f1cf856e64b" title="Add stars from the bright star catalogue.">addBrightStarCatalogue</a> ();
<a name="l00069"></a>00069         }
<a name="l00070"></a>00070     }
<a name="l00071"></a>00071 
<a name="l00072"></a><a class="code" href="classCaelum_1_1PointStarfield.html#19b6fc1838e2ace8c781f4179b65ef03">00072</a>     <a class="code" href="classCaelum_1_1PointStarfield.html#19b6fc1838e2ace8c781f4179b65ef03" title="Destructor.">PointStarfield::~PointStarfield</a> ()
<a name="l00073"></a>00073     {
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075 
<a name="l00076"></a><a class="code" href="classCaelum_1_1PointStarfield.html#323ece9b02fc96a9a9c8bdbf51f71c4b">00076</a>     <span class="keywordtype">void</span> <a class="code" href="classCaelum_1_1PointStarfield.html#323ece9b02fc96a9a9c8bdbf51f71c4b" title="You must call this if you change the star vector by hand.">PointStarfield::notifyStarVectorChanged</a> () {
<a name="l00077"></a>00077         invalidateGeometry ();
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="classCaelum_1_1PointStarfield.html#a79410c30c8bd689bba46cce7ffbb6f0">00080</a>     <span class="keywordtype">void</span> <a class="code" href="classCaelum_1_1PointStarfield.html#a79410c30c8bd689bba46cce7ffbb6f0" title="Clear any and all stars.">PointStarfield::clearAllStars</a> () {
<a name="l00081"></a>00081         mStars.clear();
<a name="l00082"></a>00082         <a class="code" href="classCaelum_1_1PointStarfield.html#323ece9b02fc96a9a9c8bdbf51f71c4b" title="You must call this if you change the star vector by hand.">notifyStarVectorChanged</a> ();
<a name="l00083"></a>00083     }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085     Real randReal () {
<a name="l00086"></a>00086         <span class="keywordflow">return</span> rand() / <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(RAND_MAX);
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088 
<a name="l00089"></a>00089     Real randReal (Real min, Real max) {
<a name="l00090"></a>00090         Real f = randReal ();
<a name="l00091"></a>00091         <span class="keywordflow">return</span> min * (1 - f) + max * f;
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="classCaelum_1_1PointStarfield.html#aa57fbef7e4876e3750adaea47d14116">00094</a>     <span class="keywordtype">void</span> <a class="code" href="classCaelum_1_1PointStarfield.html#aa57fbef7e4876e3750adaea47d14116" title="Add a bunch of random stars.">PointStarfield::addRandomStars</a> (<span class="keywordtype">int</span> count)
<a name="l00095"></a>00095     {
<a name="l00096"></a>00096         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; ++i) {
<a name="l00097"></a>00097             <span class="comment">// Generate a vector inside a sphere</span>
<a name="l00098"></a>00098             Ogre::Vector3 pos;
<a name="l00099"></a>00099             <span class="keywordflow">do</span> {
<a name="l00100"></a>00100                 pos.x = randReal(-1, 1);
<a name="l00101"></a>00101                 pos.y = randReal(-1, 1);
<a name="l00102"></a>00102                 pos.z = randReal(-1, 1);
<a name="l00103"></a>00103             } <span class="keywordflow">while</span> (pos.squaredLength () &gt;= 1);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105             <span class="comment">// Convert to rasc/decl angles.</span>
<a name="l00106"></a>00106             LongReal rasc, decl, dist;
<a name="l00107"></a>00107             Astronomy::convertRectangularToSpherical(
<a name="l00108"></a>00108                     pos.x, pos.y, pos.z,
<a name="l00109"></a>00109                     rasc, decl, dist);
<a name="l00110"></a>00110 
<a name="l00111"></a>00111             <a class="code" href="structCaelum_1_1PointStarfield_1_1Star.html" title="Struct representing one star inside PointStarfield.">Star</a> s;
<a name="l00112"></a>00112             s.RightAscension = Ogre::Degree (rasc);
<a name="l00113"></a>00113             s.Declination = Ogre::Degree (decl);
<a name="l00114"></a>00114             <span class="comment">// This distribution is wrong.</span>
<a name="l00115"></a>00115             s.Magnitude = 6 * pos.squaredLength () + 1.5;
<a name="l00116"></a>00116             mStars.push_back(s);
<a name="l00117"></a>00117         }
<a name="l00118"></a>00118         <a class="code" href="classCaelum_1_1PointStarfield.html#323ece9b02fc96a9a9c8bdbf51f71c4b" title="You must call this if you change the star vector by hand.">notifyStarVectorChanged</a> ();
<a name="l00119"></a>00119     }
<a name="l00120"></a>00120 
<a name="l00121"></a><a class="code" href="classCaelum_1_1PointStarfield.html#6f7c8bf216574c29e88f6c1ef6b0272c">00121</a>     <span class="keywordtype">void</span> <a class="code" href="classCaelum_1_1PointStarfield.html#6f7c8bf216574c29e88f6c1ef6b0272c" title="Add one star from the bright star catalogue.">PointStarfield::addStar</a> (<span class="keyword">const</span> <a class="code" href="structCaelum_1_1BrightStarCatalogueEntry.html" title="POD for bright star catalogue entries.">BrightStarCatalogueEntry</a> &amp;entry) {
<a name="l00122"></a>00122         <a class="code" href="structCaelum_1_1PointStarfield_1_1Star.html" title="Struct representing one star inside PointStarfield.">Star</a> s;
<a name="l00123"></a>00123         s.RightAscension = Ogre::Degree(360 / 24.0f * (
<a name="l00124"></a>00124                 Math::Abs(entry.rasc_hour) +
<a name="l00125"></a>00125                 entry.rasc_min / 60.0f +
<a name="l00126"></a>00126                 entry.rasc_sec / 3600.0f));
<a name="l00127"></a>00127         s.Declination = Ogre::Degree(Math::Sign(entry.decl_deg) * (
<a name="l00128"></a>00128                 Math::Abs(entry.decl_deg) +
<a name="l00129"></a>00129                 entry.decl_min / 60.0f +
<a name="l00130"></a>00130                 entry.decl_sec / 3600.0f));
<a name="l00131"></a>00131         s.Magnitude = entry.magn;
<a name="l00132"></a>00132         mStars.push_back(s);
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         <a class="code" href="classCaelum_1_1PointStarfield.html#323ece9b02fc96a9a9c8bdbf51f71c4b" title="You must call this if you change the star vector by hand.">notifyStarVectorChanged</a> ();
<a name="l00135"></a>00135     }
<a name="l00136"></a>00136 
<a name="l00137"></a><a class="code" href="classCaelum_1_1PointStarfield.html#5a82c953f3c6bff038100f1cf856e64b">00137</a>     <span class="keywordtype">void</span> <a class="code" href="classCaelum_1_1PointStarfield.html#5a82c953f3c6bff038100f1cf856e64b" title="Add stars from the bright star catalogue.">PointStarfield::addBrightStarCatalogue</a> (<span class="keywordtype">int</span> count) {
<a name="l00138"></a>00138         assert(count &gt;= 0);
<a name="l00139"></a>00139         <span class="keywordflow">if</span> (count &lt; BrightStarCatalogueSize) {
<a name="l00140"></a>00140             <span class="comment">// Only sort if we don't add everything.</span>
<a name="l00141"></a>00141             <span class="comment">// It would be lovely if the catalogue was already sorted.</span>
<a name="l00142"></a>00142             std::vector&lt;std::pair&lt;Real, int&gt; &gt; vec;
<a name="l00143"></a>00143             vec.reserve(BrightStarCatalogueSize);
<a name="l00144"></a>00144             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; BrightStarCatalogueSize; ++i) {
<a name="l00145"></a>00145                 vec.push_back(std::make_pair(BrightStarCatalogue[i].magn, i));
<a name="l00146"></a>00146             }
<a name="l00147"></a>00147             sort(vec.begin(), vec.end());
<a name="l00148"></a>00148             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; ++i) {
<a name="l00149"></a>00149                 <a class="code" href="classCaelum_1_1PointStarfield.html#6f7c8bf216574c29e88f6c1ef6b0272c" title="Add one star from the bright star catalogue.">addStar</a>(BrightStarCatalogue[vec[i].second]);
<a name="l00150"></a>00150             }
<a name="l00151"></a>00151         } <span class="keywordflow">else</span> {
<a name="l00152"></a>00152             assert(count == BrightStarCatalogueSize);
<a name="l00153"></a>00153             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; BrightStarCatalogueSize; ++i) {
<a name="l00154"></a>00154                 <a class="code" href="classCaelum_1_1PointStarfield.html#6f7c8bf216574c29e88f6c1ef6b0272c" title="Add one star from the bright star catalogue.">addStar</a>(BrightStarCatalogue[i]);
<a name="l00155"></a>00155             }
<a name="l00156"></a>00156         }
<a name="l00157"></a>00157         <a class="code" href="classCaelum_1_1PointStarfield.html#323ece9b02fc96a9a9c8bdbf51f71c4b" title="You must call this if you change the star vector by hand.">notifyStarVectorChanged</a> ();
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <span class="keywordtype">void</span> PointStarfield::invalidateGeometry () {
<a name="l00161"></a>00161         mValidGeometry = <span class="keyword">false</span>;
<a name="l00162"></a>00162     }
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="keywordtype">void</span> PointStarfield::ensureGeometry ()
<a name="l00165"></a>00165     {
<a name="l00166"></a>00166         <span class="keywordflow">if</span> (mValidGeometry) {
<a name="l00167"></a>00167             <span class="keywordflow">return</span>;
<a name="l00168"></a>00168         }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         <span class="comment">//Ogre::LogManager::getSingleton ().logMessage ("Caelum: Recomputing starfield geometry.");</span>
<a name="l00171"></a>00171 
<a name="l00172"></a>00172         <span class="keywordtype">size_t</span> starCount = mStars.size();
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         mManualObj-&gt;clear();
<a name="l00175"></a>00175         mManualObj-&gt;estimateVertexCount(6 * starCount);
<a name="l00176"></a>00176         mManualObj-&gt;begin(mMaterial-&gt;getName (), Ogre::RenderOperation::OT_TRIANGLE_LIST);
<a name="l00177"></a>00177         <span class="keywordflow">for</span> (uint i = 0; i &lt; starCount; ++i)
<a name="l00178"></a>00178         {
<a name="l00179"></a>00179             <span class="keyword">const</span> Star&amp; star = mStars[i];
<a name="l00180"></a>00180 
<a name="l00181"></a>00181             <span class="comment">// Determine position at J2000</span>
<a name="l00182"></a>00182             LongReal azm, alt;
<a name="l00183"></a>00183             <a class="code" href="classCaelum_1_1Astronomy.html#24ac9f44eeb20d8e33fbc740445a5010" title="Convert from equatorial to horizontal coordinates.">Astronomy::convertEquatorialToHorizontal</a>(
<a name="l00184"></a>00184                     <a class="code" href="classCaelum_1_1Astronomy.html#153c733a2ea973d92626fa2932d6d66a" title="January 1, 2000, noon.">Astronomy::J2000</a>,
<a name="l00185"></a>00185                     mObserverLatitude.valueDegrees(),
<a name="l00186"></a>00186                     mObserverLongitude.valueDegrees(),
<a name="l00187"></a>00187                     star.RightAscension.valueDegrees(), star.Declination.valueDegrees(),
<a name="l00188"></a>00188                     azm, alt);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190             Ogre::Vector3 pos;
<a name="l00191"></a>00191             pos.z = -Math::Cos (Ogre::Degree(azm)) * Math::Cos (Ogre::Degree(alt));
<a name="l00192"></a>00192             pos.x =  Math::Sin (Ogre::Degree(azm)) * Math::Cos (Ogre::Degree(alt));
<a name="l00193"></a>00193             pos.y = -Math::Sin (Ogre::Degree(alt));
<a name="l00194"></a>00194 
<a name="l00195"></a>00195             <span class="comment">//mManualObj-&gt;colour (Ogre::ColourValue::White);</span>
<a name="l00196"></a>00196             mManualObj-&gt;position (pos);
<a name="l00197"></a>00197             mManualObj-&gt;textureCoord (+1, -1, star.Magnitude);
<a name="l00198"></a>00198             mManualObj-&gt;position (pos);
<a name="l00199"></a>00199             mManualObj-&gt;textureCoord (+1, +1, star.Magnitude);
<a name="l00200"></a>00200             mManualObj-&gt;position (pos);
<a name="l00201"></a>00201             mManualObj-&gt;textureCoord (-1, -1, star.Magnitude);
<a name="l00202"></a>00202 
<a name="l00203"></a>00203             mManualObj-&gt;position (pos);
<a name="l00204"></a>00204             mManualObj-&gt;textureCoord (-1, -1, star.Magnitude);
<a name="l00205"></a>00205             mManualObj-&gt;position (pos);
<a name="l00206"></a>00206             mManualObj-&gt;textureCoord (+1, +1, star.Magnitude);
<a name="l00207"></a>00207             mManualObj-&gt;position (pos);
<a name="l00208"></a>00208             mManualObj-&gt;textureCoord (-1, +1, star.Magnitude);
<a name="l00209"></a>00209         }
<a name="l00210"></a>00210         mManualObj-&gt;end();
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         <span class="comment">// Set infinite bounds on the starfield.</span>
<a name="l00213"></a>00213         AxisAlignedBox box;
<a name="l00214"></a>00214         box.setInfinite ();
<a name="l00215"></a>00215         mManualObj-&gt;setBoundingBox (box);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         mValidGeometry = <span class="keyword">true</span>;
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219     
<a name="l00220"></a>00220     <span class="keywordtype">void</span> PointStarfield::Params::setup(Ogre::GpuProgramParametersSharedPtr vpParams)
<a name="l00221"></a>00221     {
<a name="l00222"></a>00222         this-&gt;vpParams = vpParams;
<a name="l00223"></a>00223         this-&gt;mag_scale.bind(vpParams, <span class="stringliteral">"mag_scale"</span>);
<a name="l00224"></a>00224         this-&gt;mag0_size.bind(vpParams, <span class="stringliteral">"mag0_size"</span>);
<a name="l00225"></a>00225         this-&gt;min_size.bind(vpParams, <span class="stringliteral">"min_size"</span>);
<a name="l00226"></a>00226         this-&gt;max_size.bind(vpParams, <span class="stringliteral">"max_size"</span>);
<a name="l00227"></a>00227         this-&gt;aspect_ratio.bind(vpParams, <span class="stringliteral">"aspect_ratio"</span>);
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 
<a name="l00230"></a><a class="code" href="classCaelum_1_1PointStarfield.html#02e0094f88bc80b87c9feb96971c7315">00230</a>     <span class="keywordtype">void</span> <a class="code" href="classCaelum_1_1PointStarfield.html#02e0094f88bc80b87c9feb96971c7315" title="Handle camera change.">PointStarfield::notifyCameraChanged</a> (Ogre::Camera *cam) {
<a name="l00231"></a>00231         <a class="code" href="classCaelum_1_1PointStarfield.html#02e0094f88bc80b87c9feb96971c7315" title="Handle camera change.">CameraBoundElement::notifyCameraChanged</a> (cam);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233         <span class="comment">// Shader params are changed for every camera.</span>
<a name="l00234"></a>00234         Pass* pass = mMaterial-&gt;getBestTechnique ()-&gt;getPass (0);
<a name="l00235"></a>00235         GpuProgramParametersSharedPtr fpParams = pass-&gt;getFragmentProgramParameters ();
<a name="l00236"></a>00236         GpuProgramParametersSharedPtr vpParams = pass-&gt;getVertexProgramParameters ();
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         <span class="keywordtype">int</span> height = cam-&gt;getViewport ()-&gt; getActualHeight ();
<a name="l00239"></a>00239         <span class="keywordtype">int</span> width = cam-&gt;getViewport ()-&gt; getActualWidth ();
<a name="l00240"></a>00240         Real pixFactor = 1.0f / width;
<a name="l00241"></a>00241         Real magScale = -Math::Log (mMagnitudeScale) / 2;
<a name="l00242"></a>00242         Real mag0Size = mMag0PixelSize * pixFactor;
<a name="l00243"></a>00243         Real minSize = mMinPixelSize * pixFactor;
<a name="l00244"></a>00244         Real maxSize = mMaxPixelSize * pixFactor;
<a name="l00245"></a>00245         Real aspectRatio = <span class="keyword">static_cast&lt;</span>Real<span class="keyword">&gt;</span>(width) / height;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         <span class="comment">// These params are relative to the size of the screen.</span>
<a name="l00248"></a>00248         mParams.mag_scale.set(mParams.vpParams, magScale);
<a name="l00249"></a>00249         mParams.mag0_size.set(mParams.vpParams, mag0Size);
<a name="l00250"></a>00250         mParams.min_size.set(mParams.vpParams, minSize);
<a name="l00251"></a>00251         mParams.max_size.set(mParams.vpParams, maxSize);
<a name="l00252"></a>00252         mParams.aspect_ratio.set(mParams.vpParams, aspectRatio);
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254 
<a name="l00255"></a><a class="code" href="classCaelum_1_1PointStarfield.html#7b245e4106b6b1f795c95cf157775c98">00255</a>     <span class="keywordtype">void</span> <a class="code" href="classCaelum_1_1PointStarfield.html#7b245e4106b6b1f795c95cf157775c98" title="Handle far radius.">PointStarfield::setFarRadius</a> (Ogre::Real radius) {
<a name="l00256"></a>00256         <a class="code" href="classCaelum_1_1PointStarfield.html#7b245e4106b6b1f795c95cf157775c98" title="Handle far radius.">CameraBoundElement::setFarRadius</a>(radius);
<a name="l00257"></a>00257         mNode-&gt;setScale (Ogre::Vector3::UNIT_SCALE * radius);
<a name="l00258"></a>00258     }
<a name="l00259"></a>00259 
<a name="l00260"></a><a class="code" href="classCaelum_1_1PointStarfield.html#8c033a4c76b02bff453f71caa9e5e327">00260</a>     <span class="keywordtype">void</span> <a class="code" href="classCaelum_1_1PointStarfield.html#8c033a4c76b02bff453f71caa9e5e327" title="Update function; called from CaelumSystem::updateSubcomponents.">PointStarfield::_update</a> (<span class="keyword">const</span> <span class="keywordtype">float</span> time) {
<a name="l00261"></a>00261         <span class="comment">// This is probably wrong.</span>
<a name="l00262"></a>00262         Ogre::Quaternion orientation = Ogre::Quaternion::IDENTITY;
<a name="l00263"></a>00263         orientation = orientation * Ogre::Quaternion (Ogre::Radian (-mObserverLatitude + Ogre::Degree (90)), Ogre::Vector3::UNIT_X);
<a name="l00264"></a>00264         orientation = orientation * Ogre::Quaternion (Ogre::Radian (-time * 2 * Ogre::Math::PI), Ogre::Vector3::UNIT_Y);
<a name="l00265"></a>00265         mNode-&gt;setOrientation (orientation);
<a name="l00266"></a>00266         ensureGeometry ();
<a name="l00267"></a>00267     }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269     <span class="keywordtype">void</span> PointStarfield::setObserverLatitude (Ogre::Degree value)
<a name="l00270"></a>00270     {
<a name="l00271"></a>00271         <span class="keywordflow">if</span> (!Math::RealEqual (
<a name="l00272"></a>00272                 mObserverLatitude.valueDegrees (),
<a name="l00273"></a>00273                 value.valueDegrees (),
<a name="l00274"></a>00274                 this-&gt;<a class="code" href="classCaelum_1_1PointStarfield.html#5632ec16462af3d179cf9da469555103" title="Moving the observer position around causes a starfield rebuild.">getObserverPositionRebuildDelta</a> ().valueDegrees ()))
<a name="l00275"></a>00275         {
<a name="l00276"></a>00276             mObserverLatitude = value;
<a name="l00277"></a>00277             invalidateGeometry ();
<a name="l00278"></a>00278         }
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     <span class="keywordtype">void</span> PointStarfield::setObserverLongitude (Ogre::Degree value)
<a name="l00282"></a>00282     {
<a name="l00283"></a>00283         <span class="keywordflow">if</span> (!Math::RealEqual (
<a name="l00284"></a>00284                 mObserverLongitude.valueDegrees (), 
<a name="l00285"></a>00285                 value.valueDegrees (),
<a name="l00286"></a>00286                 this-&gt;<a class="code" href="classCaelum_1_1PointStarfield.html#5632ec16462af3d179cf9da469555103" title="Moving the observer position around causes a starfield rebuild.">getObserverPositionRebuildDelta</a> ().valueDegrees ()))
<a name="l00287"></a>00287         {
<a name="l00288"></a>00288             mObserverLongitude = value;
<a name="l00289"></a>00289             invalidateGeometry ();
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291     }
<a name="l00292"></a>00292 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Aug 9 10:48:55 2009 for Caelum by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
